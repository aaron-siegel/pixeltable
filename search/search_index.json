{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Pixeltable API This is the API documentation for Pixeltable. Main Pixeltable documentation: https://pixeltable.readme.io/ Pixeltable github project: https://github.com/pixeltable/pixeltable/","title":"Home"},{"location":"#pixeltable-api","text":"This is the API documentation for Pixeltable. Main Pixeltable documentation: https://pixeltable.readme.io/ Pixeltable github project: https://github.com/pixeltable/pixeltable/","title":"Pixeltable API"},{"location":"api-cheat-sheet/","text":"API Cheat Sheet Import conventions: import pixeltable as pxt import pixeltable.functions as pxtf Operations summary Task Code Create a (mutable) table t = pxt.create_table ('table_name', {'col_1': pxt.StringType(), 'col_2': pxt.IntType(), ...}) Create a view t = pxt.create_view ('view_name', base_tbl, filter=base_tbl.col > 10) Create a view with iterator t = pxt.create_view ('view_name', base_tbl, iterator=FrameIterator.create(video=base_tbl.col, fps=0)) Create a snapshot t = pxt.create_view ('snapshot_name', t, is_snapshot=True) The following functions apply to tables, views, and snapshots. Task Code Use an existing table t = pxt.get_table ('video_data') Rename a table pxt.move ('video_data', 'vd') Move a table pxt.move ('video_data', 'experiments.video_data') List tables pxt.list_tables () Delete a table pxt.drop_table ('video_data') Directories Task Code Create a directory pxt.create_dir ('experiments') Rename or move a directory pxt.move ('experiments', 'project_x.experiments') Delete a directory f = pxt.rm_dir ('experiments') List directories pxt.list_dirs ('project_x') Frame extraction for video data Create a table with video data and view for the frames: import pixeltable as pxt from pixeltable.iterators import FrameIterator t = pxt.create_table('tbl_name', {'video': pxt.VideoType()}) f = pxt.create_view('frame_view_name', t, iterator=FrameIterator.create(videos=t, fps=0)) fps=0 extracts frames at the original frame rate. Pixeltable types Pixeltable type Python type pxt.StringType() str pxt.IntType() int pxt.FloatType() float pxt.BoolType() bool pxt.TimestampType() datetime.datetime pxt.JsonType() list or dict pxt.ArrayType() numpy.ndarray pxt.ImageType() PIL.Image.Image pxt.VideoType() str (the file path or URL) pxt.AudioType() str (the file path or URL) Table operations summary Action Code Print table schema t. describe () Query a table t. select (t.col2, t.col3 + 5).where(t.col1 == 'green').show() Insert a single row into a table t. insert (col1='green', ...) Insert multiple rows into a table t. insert ([{'col1': 'green', ...}, {'col1': 'red', ...}, ...]) Add a column t. add_column (new_col_name=pxt.IntType()) Add a column (alternate form) t[new_col_name] = pxt.IntType() Rename a column t. rename_column ('col_name', 'new_col_name') Drop a column t. drop_column ('col_name') Undo the last update operation (add/rename/drop column or insert) t. revert () Querying a table Action Code Look at 10 rows t. show (10) Look at the oldest 10 rows t. head (10) Look at the most recently added 10 rows t. tail (10) Look at all rows t. collect () Iterate over all rows as dictionaries for row in t. collect (): ... Look at row for frame 15 t. where (t.pos == 15).show() Look at rows before index 15 t. where (t.pos < 15).show() Look at rows before index 15 with RGB frames t. where ((t.pos < 15) & (t.frame.mode == 'RGB')).collect() Pixeltable supports the standard comparison operators ( >= , > , == , <= , < ). == None is the equivalent of isna()/isnull() in Pandas. Boolean operators are the same as in Pandas: & for and , | for or , ~ for not . They also require parentheses, for example: (t.pos < 15) & (t.frame.mode == 'RGB') or ~(t.frame.mode == 'RGB') . Selecting and transforming columns Action Code Only retrieve the frame index and frame t. select (t.frame_idx, t.frame).collect() Look at frames rotated 90 degrees t. select (t.frame.rotate(90)).collect() Overlay frame with itself rotated 90 degrees t. select (pxt.functions.pil.image.blend(t.frame, t.frame.rotate(90))).collect() Computed columns The values in a computed column are automatically filled when data is added: t.add_column(c_added=t.frame.rotate(30)) Alternatively: t['c_added'] = t.frame.rotate(30) Computed columns and media columns (video, image, audio) have attributes errortype and errormsg , which contain the exception type and string in rows where the computation expression or media type validation results in an exception (the column value itself will be None ). Example: t.where(t.c_added.errortype != None).select(t.c_added.errortype, t.c_added.errormsg).show() returns the exception type and message for rows with an exception. Inserting data into a table t.insert([{'video': '/path/to/video1.mp4'}, {'video': '/path/to/video2.mp4'}]) Each row is a dictionary mapping column names to column values (do not provide values for computed columns). Attributes and methods on image data Images are represented as PIL.Image.Image instances in memory and support a lot of the attributes and methods documented here . Available attributes are: mode , height , width . Available methods are: convert , crop , effect_spread , entropy , filter , getbands , getbbox , getchannel , getcolors , getextrema , getpalette , getpixel , getprojection , histogram , point , quantize , reduce , remap_palette , resize , rotate , transform , transpose . Methods can be chained, for example: t.frame.resize((224, 224)).rotate(90).convert('L')","title":"API Cheat Sheet"},{"location":"api-cheat-sheet/#api-cheat-sheet","text":"Import conventions: import pixeltable as pxt import pixeltable.functions as pxtf","title":"API Cheat Sheet"},{"location":"api-cheat-sheet/#operations-summary","text":"Task Code Create a (mutable) table t = pxt.create_table ('table_name', {'col_1': pxt.StringType(), 'col_2': pxt.IntType(), ...}) Create a view t = pxt.create_view ('view_name', base_tbl, filter=base_tbl.col > 10) Create a view with iterator t = pxt.create_view ('view_name', base_tbl, iterator=FrameIterator.create(video=base_tbl.col, fps=0)) Create a snapshot t = pxt.create_view ('snapshot_name', t, is_snapshot=True) The following functions apply to tables, views, and snapshots. Task Code Use an existing table t = pxt.get_table ('video_data') Rename a table pxt.move ('video_data', 'vd') Move a table pxt.move ('video_data', 'experiments.video_data') List tables pxt.list_tables () Delete a table pxt.drop_table ('video_data')","title":"Operations summary"},{"location":"api-cheat-sheet/#directories","text":"Task Code Create a directory pxt.create_dir ('experiments') Rename or move a directory pxt.move ('experiments', 'project_x.experiments') Delete a directory f = pxt.rm_dir ('experiments') List directories pxt.list_dirs ('project_x')","title":"Directories"},{"location":"api-cheat-sheet/#frame-extraction-for-video-data","text":"Create a table with video data and view for the frames: import pixeltable as pxt from pixeltable.iterators import FrameIterator t = pxt.create_table('tbl_name', {'video': pxt.VideoType()}) f = pxt.create_view('frame_view_name', t, iterator=FrameIterator.create(videos=t, fps=0)) fps=0 extracts frames at the original frame rate.","title":"Frame extraction for video data"},{"location":"api-cheat-sheet/#pixeltable-types","text":"Pixeltable type Python type pxt.StringType() str pxt.IntType() int pxt.FloatType() float pxt.BoolType() bool pxt.TimestampType() datetime.datetime pxt.JsonType() list or dict pxt.ArrayType() numpy.ndarray pxt.ImageType() PIL.Image.Image pxt.VideoType() str (the file path or URL) pxt.AudioType() str (the file path or URL)","title":"Pixeltable types"},{"location":"api-cheat-sheet/#table-operations-summary","text":"Action Code Print table schema t. describe () Query a table t. select (t.col2, t.col3 + 5).where(t.col1 == 'green').show() Insert a single row into a table t. insert (col1='green', ...) Insert multiple rows into a table t. insert ([{'col1': 'green', ...}, {'col1': 'red', ...}, ...]) Add a column t. add_column (new_col_name=pxt.IntType()) Add a column (alternate form) t[new_col_name] = pxt.IntType() Rename a column t. rename_column ('col_name', 'new_col_name') Drop a column t. drop_column ('col_name') Undo the last update operation (add/rename/drop column or insert) t. revert ()","title":"Table operations summary"},{"location":"api-cheat-sheet/#querying-a-table","text":"Action Code Look at 10 rows t. show (10) Look at the oldest 10 rows t. head (10) Look at the most recently added 10 rows t. tail (10) Look at all rows t. collect () Iterate over all rows as dictionaries for row in t. collect (): ... Look at row for frame 15 t. where (t.pos == 15).show() Look at rows before index 15 t. where (t.pos < 15).show() Look at rows before index 15 with RGB frames t. where ((t.pos < 15) & (t.frame.mode == 'RGB')).collect() Pixeltable supports the standard comparison operators ( >= , > , == , <= , < ). == None is the equivalent of isna()/isnull() in Pandas. Boolean operators are the same as in Pandas: & for and , | for or , ~ for not . They also require parentheses, for example: (t.pos < 15) & (t.frame.mode == 'RGB') or ~(t.frame.mode == 'RGB') .","title":"Querying a table"},{"location":"api-cheat-sheet/#selecting-and-transforming-columns","text":"Action Code Only retrieve the frame index and frame t. select (t.frame_idx, t.frame).collect() Look at frames rotated 90 degrees t. select (t.frame.rotate(90)).collect() Overlay frame with itself rotated 90 degrees t. select (pxt.functions.pil.image.blend(t.frame, t.frame.rotate(90))).collect()","title":"Selecting and transforming columns"},{"location":"api-cheat-sheet/#computed-columns","text":"The values in a computed column are automatically filled when data is added: t.add_column(c_added=t.frame.rotate(30)) Alternatively: t['c_added'] = t.frame.rotate(30) Computed columns and media columns (video, image, audio) have attributes errortype and errormsg , which contain the exception type and string in rows where the computation expression or media type validation results in an exception (the column value itself will be None ). Example: t.where(t.c_added.errortype != None).select(t.c_added.errortype, t.c_added.errormsg).show() returns the exception type and message for rows with an exception.","title":"Computed columns"},{"location":"api-cheat-sheet/#inserting-data-into-a-table","text":"t.insert([{'video': '/path/to/video1.mp4'}, {'video': '/path/to/video2.mp4'}]) Each row is a dictionary mapping column names to column values (do not provide values for computed columns).","title":"Inserting data into a table"},{"location":"api-cheat-sheet/#attributes-and-methods-on-image-data","text":"Images are represented as PIL.Image.Image instances in memory and support a lot of the attributes and methods documented here . Available attributes are: mode , height , width . Available methods are: convert , crop , effect_spread , entropy , filter , getbands , getbbox , getchannel , getcolors , getextrema , getpalette , getpixel , getprojection , histogram , point , quantize , reduce , remap_palette , resize , rotate , transform , transpose . Methods can be chained, for example: t.frame.resize((224, 224)).rotate(90).convert('L')","title":"Attributes and methods on image data"},{"location":"differences-with-pandas/","text":"Differences with Pandas Pandas Pixeltable reading data Read from file system with pd.read_* methods: eg, .csv , .json , .parquet , etc. In pixeltable , data is stored in tables. cl.list_tables , tab = cl.get_table('mytable') saving data (fist time) Save to file system, format of choice table.insert updating data to update data persistently, use pd.write_*() to over-write or save new versions of the dataset table.update statements on tables allow for fine-grained persistent updates only on columns with specific values selecting rows df[ df.col > 1 ] tab.where(tab.col > 1) selecting rows (predicates) df[(df.a > 0) & (df.b > 0)] df.where((df.a > 0) & (df.b > 0)) both will error if and or or is used. selecting columns (aka projection) df[['col']] tab.select(tab.col) new column with computed value df.assign(new_col= fun(df.input_col1, df.input_col2,..)) or df['new_col'] = fun(df.input_col1, df.input_col2,..)) (the latter acts in-place, modifying the df object) tab.select(old_colA, old_colB, new_col=fun(tab.input_col1, tab.input_col2,...)) computing new values row by row df['new_col'] = df.apply(fun, axis=1) df.select(old_colA, old_colB, ..., new_col=pxt.function(fun)(tab.input_col1, tab.input_col2,...)","title":"Differences with Pandas"},{"location":"differences-with-pandas/#differences-with-pandas","text":"Pandas Pixeltable reading data Read from file system with pd.read_* methods: eg, .csv , .json , .parquet , etc. In pixeltable , data is stored in tables. cl.list_tables , tab = cl.get_table('mytable') saving data (fist time) Save to file system, format of choice table.insert updating data to update data persistently, use pd.write_*() to over-write or save new versions of the dataset table.update statements on tables allow for fine-grained persistent updates only on columns with specific values selecting rows df[ df.col > 1 ] tab.where(tab.col > 1) selecting rows (predicates) df[(df.a > 0) & (df.b > 0)] df.where((df.a > 0) & (df.b > 0)) both will error if and or or is used. selecting columns (aka projection) df[['col']] tab.select(tab.col) new column with computed value df.assign(new_col= fun(df.input_col1, df.input_col2,..)) or df['new_col'] = fun(df.input_col1, df.input_col2,..)) (the latter acts in-place, modifying the df object) tab.select(old_colA, old_colB, new_col=fun(tab.input_col1, tab.input_col2,...)) computing new values row by row df['new_col'] = df.apply(fun, axis=1) df.select(old_colA, old_colB, ..., new_col=pxt.function(fun)(tab.input_col1, tab.input_col2,...)","title":"Differences with Pandas"},{"location":"getting-started/","text":"Getting Started with Pixeltable This is a step-by-step guide to setting up a local installation of Pixeltable. You'll want to install Pixeltable in a Python virtual environment; we'll use Apache Miniconda in this guide, but any environment manager should work. Pixeltable works with Python 3.9, 3.10, or 3.11 running on Linux or MacOS. Install Pixeltable Install Miniconda here: Installing Miniconda Create your environment: conda create --name pxt python=3.10 conda activate pxt Install pixeltable and Jupyter inside the new environment: pip install pixeltable jupyter Create a Notebook Start your Jupyter notebook server: jupyter notebook Create a new notebook: Select \"Python 3 (ipykernel)\" as the kernel File / New / Notebook Test that everything is working by entering these commands into the notebook: import pixeltable as pxt pxt.list_tables() Wait a minute for Pixeltable to load; then you should see a message indicating that Pixeltable has successfully connected to the database. (The call to pxt.list_tables() will return an empty list, because you haven't created any tables yet.) At this point, you're set up to start using Pixeltable! For a tour of what it can do, a good place to start is the Pixeltable Basics tutorial.","title":"Getting Started with Pixeltable"},{"location":"getting-started/#getting-started-with-pixeltable","text":"This is a step-by-step guide to setting up a local installation of Pixeltable. You'll want to install Pixeltable in a Python virtual environment; we'll use Apache Miniconda in this guide, but any environment manager should work. Pixeltable works with Python 3.9, 3.10, or 3.11 running on Linux or MacOS.","title":"Getting Started with Pixeltable"},{"location":"getting-started/#install-pixeltable","text":"Install Miniconda here: Installing Miniconda Create your environment: conda create --name pxt python=3.10 conda activate pxt Install pixeltable and Jupyter inside the new environment: pip install pixeltable jupyter","title":"Install Pixeltable"},{"location":"getting-started/#create-a-notebook","text":"Start your Jupyter notebook server: jupyter notebook Create a new notebook: Select \"Python 3 (ipykernel)\" as the kernel File / New / Notebook Test that everything is working by entering these commands into the notebook: import pixeltable as pxt pxt.list_tables() Wait a minute for Pixeltable to load; then you should see a message indicating that Pixeltable has successfully connected to the database. (The call to pxt.list_tables() will return an empty list, because you haven't created any tables yet.) At this point, you're set up to start using Pixeltable! For a tour of what it can do, a good place to start is the Pixeltable Basics tutorial.","title":"Create a Notebook"},{"location":"api/data-frame/","text":"DataFrame DataFrame represents a query against a specific table. Unlike computation container frameworks like pandas or Dask, Pixeltable dataframes do not hold data or allow you to update data (use insert / update / delete for that purpose). Another difference to pandas is that query execution needs to be initiated explicitly in order to return results. Overview Query Construction select Select output expressions where Filter table rows group_by Group table rows in order to apply aggregate functions order_by Order output rows limit Limit the number of output rows Query Execution collect Return all output rows show Return a number of output rows head Return the oldest rows tail Return the most recently added rows Data Export to_pytorch_dataset Return the query result as a pytorch IterableDataset to_coco_dataset Return the query result as a COCO dataset pixeltable.DataFrame collect collect () -> DataFrameResultSet group_by group_by ( * grouping_items : Any ) -> DataFrame Add a group-by clause to this DataFrame. Variants: - group_by( ): group a component view by their respective base table rows - group_by( , ...): group by the given expressions head head ( n : int = 10 ) -> DataFrameResultSet limit limit ( n : int ) -> DataFrame order_by order_by ( * expr_list : Expr , asc : bool = True ) -> DataFrame select select ( * items : Any , ** named_items : Any ) -> DataFrame show show ( n : int = 20 ) -> DataFrameResultSet tail tail ( n : int = 10 ) -> DataFrameResultSet to_pytorch_dataset to_pytorch_dataset ( image_format : str = \"pt\" , ) -> \"torch.utils.data.IterableDataset\" Convert the dataframe to a pytorch IterableDataset suitable for parallel loading with torch.utils.data.DataLoader. This method requires pyarrow >= 13, torch and torchvision to work. This method serializes data so it can be read from disk efficiently and repeatedly without re-executing the query. This data is cached to disk for future re-use. Parameters: image_format ( str , default: 'pt' ) \u2013 format of the images. Can be 'pt' (pytorch tensor) or 'np' (numpy array). 'np' means image columns return as an RGB uint8 array of shape HxWxC. 'pt' means image columns return as a CxHxW tensor with values in [0,1] and type torch.float32. (the format output by torchvision.transforms.ToTensor()) Returns: 'torch.utils.data.IterableDataset' \u2013 A pytorch IterableDataset: Columns become fields of the dataset, where rows are returned as a dictionary compatible with torch.utils.data.DataLoader default collation. Constraints The default collate_fn for torch.data.util.DataLoader cannot represent null values as part of a pytorch tensor when forming batches. These values will raise an exception while running the dataloader. If you have them, you can work around None values by providing your custom collate_fn to the DataLoader (and have your model handle it). Or, if these are not meaningful values within a minibtach, you can modify or remove any such values through selections and filters prior to calling to_pytorch_dataset(). to_coco_dataset to_coco_dataset () -> Path Convert the dataframe to a COCO dataset. This dataframe must return a single json-typed output column in the following format: { 'image': PIL.Image.Image, 'annotations': [ { 'bbox': [x: int, y: int, w: int, h: int], 'category': str | int, }, ... ], } Returns: Path \u2013 Path to the COCO dataset file. where where ( pred : Predicate ) -> DataFrame","title":"DataFrame"},{"location":"api/data-frame/#dataframe","text":"DataFrame represents a query against a specific table. Unlike computation container frameworks like pandas or Dask, Pixeltable dataframes do not hold data or allow you to update data (use insert / update / delete for that purpose). Another difference to pandas is that query execution needs to be initiated explicitly in order to return results.","title":"DataFrame"},{"location":"api/data-frame/#overview","text":"Query Construction select Select output expressions where Filter table rows group_by Group table rows in order to apply aggregate functions order_by Order output rows limit Limit the number of output rows Query Execution collect Return all output rows show Return a number of output rows head Return the oldest rows tail Return the most recently added rows Data Export to_pytorch_dataset Return the query result as a pytorch IterableDataset to_coco_dataset Return the query result as a COCO dataset","title":"Overview"},{"location":"api/data-frame/#pixeltable.DataFrame","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;DataFrame"},{"location":"api/data-frame/#pixeltable.DataFrame.collect","text":"collect () -> DataFrameResultSet","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;collect"},{"location":"api/data-frame/#pixeltable.DataFrame.group_by","text":"group_by ( * grouping_items : Any ) -> DataFrame Add a group-by clause to this DataFrame. Variants: - group_by( ): group a component view by their respective base table rows - group_by( , ...): group by the given expressions","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;group_by"},{"location":"api/data-frame/#pixeltable.DataFrame.head","text":"head ( n : int = 10 ) -> DataFrameResultSet","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;head"},{"location":"api/data-frame/#pixeltable.DataFrame.limit","text":"limit ( n : int ) -> DataFrame","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;limit"},{"location":"api/data-frame/#pixeltable.DataFrame.order_by","text":"order_by ( * expr_list : Expr , asc : bool = True ) -> DataFrame","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;order_by"},{"location":"api/data-frame/#pixeltable.DataFrame.select","text":"select ( * items : Any , ** named_items : Any ) -> DataFrame","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;select"},{"location":"api/data-frame/#pixeltable.DataFrame.show","text":"show ( n : int = 20 ) -> DataFrameResultSet","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;show"},{"location":"api/data-frame/#pixeltable.DataFrame.tail","text":"tail ( n : int = 10 ) -> DataFrameResultSet","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;tail"},{"location":"api/data-frame/#pixeltable.DataFrame.to_pytorch_dataset","text":"to_pytorch_dataset ( image_format : str = \"pt\" , ) -> \"torch.utils.data.IterableDataset\" Convert the dataframe to a pytorch IterableDataset suitable for parallel loading with torch.utils.data.DataLoader. This method requires pyarrow >= 13, torch and torchvision to work. This method serializes data so it can be read from disk efficiently and repeatedly without re-executing the query. This data is cached to disk for future re-use. Parameters: image_format ( str , default: 'pt' ) \u2013 format of the images. Can be 'pt' (pytorch tensor) or 'np' (numpy array). 'np' means image columns return as an RGB uint8 array of shape HxWxC. 'pt' means image columns return as a CxHxW tensor with values in [0,1] and type torch.float32. (the format output by torchvision.transforms.ToTensor()) Returns: 'torch.utils.data.IterableDataset' \u2013 A pytorch IterableDataset: Columns become fields of the dataset, where rows are returned as a dictionary compatible with torch.utils.data.DataLoader default collation. Constraints The default collate_fn for torch.data.util.DataLoader cannot represent null values as part of a pytorch tensor when forming batches. These values will raise an exception while running the dataloader. If you have them, you can work around None values by providing your custom collate_fn to the DataLoader (and have your model handle it). Or, if these are not meaningful values within a minibtach, you can modify or remove any such values through selections and filters prior to calling to_pytorch_dataset().","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;to_pytorch_dataset"},{"location":"api/data-frame/#pixeltable.DataFrame.to_coco_dataset","text":"to_coco_dataset () -> Path Convert the dataframe to a COCO dataset. This dataframe must return a single json-typed output column in the following format: { 'image': PIL.Image.Image, 'annotations': [ { 'bbox': [x: int, y: int, w: int, h: int], 'category': str | int, }, ... ], } Returns: Path \u2013 Path to the COCO dataset file.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;to_coco_dataset"},{"location":"api/data-frame/#pixeltable.DataFrame.where","text":"where ( pred : Predicate ) -> DataFrame","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;where"},{"location":"api/insertable-table/","text":"InsertableTable Import conventions: import pixeltable as pxt Instances of class InsertableTable are handles to Pixeltable tables. Use this handle to query and update the table and to add and drop columns. InsertableTable instances are created by calling pxt.create_table or pxt.get_table . Overview Column Operations add_column Add a column to the table drop_column Remove a column from the table rename_column Rename a column Data Operations insert Insert rows into table update Upate rows in table delete Delete rows from table Versioning revert Revert the last change pixeltable.InsertableTable A Table that allows inserting and deleting rows. add_column add_column ( * , type : Optional [ ColumnType ] = None , stored : Optional [ bool ] = None , print_stats : bool = False , ** kwargs : Any ) -> UpdateStatus Adds a column to the table. Parameters: kwargs ( Any , default: {} ) \u2013 Exactly one keyword argument of the form column-name=type|value-expression . type ( Optional [ ColumnType ] , default: None ) \u2013 The type of the column. Only valid and required if value-expression is a Callable. stored ( Optional [ bool ] , default: None ) \u2013 Whether the column is materialized and stored or computed on demand. Only valid for image columns. print_stats ( bool , default: False ) \u2013 If True , print execution metrics. Returns: UpdateStatus \u2013 execution status Raises: Error \u2013 If the column name is invalid or already exists. Examples: Add an int column with None values: >>> tbl . add_column ( new_col = IntType ()) Alternatively, this can also be expressed as: >>> tbl [ 'new_col' ] = IntType () For a table with int column int_col , add a column that is the factorial of int_col . The names of the parameters of the Callable must correspond to existing column names (the column values are then passed as arguments to the Callable). In this case, the column type needs to be specified explicitly: >>> tbl . add_column ( factorial = lambda int_col : math . factorial ( int_col ), type = IntType ()) Alternatively, this can also be expressed as: >>> tbl [ 'factorial' ] = { 'value' : lambda int_col : math . factorial ( int_col ), 'type' : IntType ()} For a table with an image column frame , add an image column rotated that rotates the image by 90 degrees. In this case, the column type is inferred from the expression. Also, the column is not stored (by default, computed image columns are not stored but recomputed on demand): >>> tbl . add_column ( rotated = tbl . frame . rotate ( 90 )) Alternatively, this can also be expressed as: >>> tbl [ 'rotated' ] = tbl . frame . rotate ( 90 ) Do the same, but now the column is stored: >>> tbl . add_column ( rotated = tbl . frame . rotate ( 90 ), stored = True ) Alternatively, this can also be expressed as: >>> tbl [ 'rotated' ] = { 'value' : tbl . frame . rotate ( 90 ), 'stored' : True } delete delete ( where : Optional [ 'pixeltable.exprs.Predicate' ] = None ) -> UpdateStatus Delete rows in this table. Parameters: where ( Optional ['pixeltable.exprs.Predicate'] , default: None ) \u2013 a Predicate to filter rows to delete. Examples: Delete all rows in a table: >>> tbl . delete () Delete all rows in a table where column a is greater than 5: >>> tbl . delete ( tbl . a > 5 ) drop_column drop_column ( name : str ) -> None Drop a column from the table. Parameters: name ( str ) \u2013 The name of the column to drop. Raises: Error \u2013 If the column does not exist or if it is referenced by a computed column. Examples: Drop column factorial : >>> tbl . drop_column ( 'factorial' ) insert insert ( * args , ** kwargs ) -> UpdateStatus Insert rows into table. To insert multiple rows at a time: insert(rows: List[Dict[str, Any]], print_stats: bool = False, fail_on_exception: bool = True) To insert just a single row, you can use the more convenient syntax: insert(print_stats: bool = False, fail_on_exception: bool = True, **kwargs: Any) Parameters: rows \u2013 (if inserting multiple rows) A list of rows to insert, each of which is a dictionary mapping column names to values. kwargs \u2013 (if inserting a single row) Keyword-argument pairs representing column names and values. print_stats \u2013 If True , print statistics about the cost of computed columns. fail_on_exception \u2013 Determines how exceptions in computed columns and invalid media files (e.g., corrupt images) are handled. If False , store error information (accessible as column properties 'errortype' and 'errormsg') for those cases, but continue inserting rows. If True , raise an exception that aborts the insert. Returns: UpdateStatus \u2013 execution status Raises: Error \u2013 if a row does not match the table schema or contains values for computed columns Examples: Insert two rows into a table with three int columns a , b , and c . Column c is nullable. >>> tbl . insert ([{ 'a' : 1 , 'b' : 1 , 'c' : 1 }, { 'a' : 2 , 'b' : 2 }]) Insert a single row into a table with three int columns a , b , and c . >>> tbl . insert ( a = 1 , b = 1 , c = 1 ) rename_column rename_column ( old_name : str , new_name : str ) -> None Rename a column. Parameters: old_name ( str ) \u2013 The current name of the column. new_name ( str ) \u2013 The new name of the column. Raises: Error \u2013 If the column does not exist or if the new name is invalid or already exists. Examples: Rename column factorial to fac : >>> tbl . rename_column ( 'factorial' , 'fac' ) revert revert () -> None Reverts the table to the previous version. .. warning:: This operation is irreversible. update update ( value_spec : dict [ str , Any ], where : Optional [ \"pixeltable.exprs.Predicate\" ] = None , cascade : bool = True , ) -> UpdateStatus Update rows in this table. Parameters: value_spec ( dict [ str , Any ] ) \u2013 a dictionary mapping column names to literal values or Pixeltable expressions. where ( Optional ['pixeltable.exprs.Predicate'] , default: None ) \u2013 a Predicate to filter rows to update. cascade ( bool , default: True ) \u2013 if True, also update all computed columns that transitively depend on the updated columns. Examples: Set column int_col to 1 for all rows: >>> tbl . update ({ 'int_col' : 1 }) Set column int_col to 1 for all rows where int_col is 0: >>> tbl . update ({ 'int_col' : 1 }, where = tbl . int_col == 0 ) Set int_col to the value of other_int_col + 1: >>> tbl . update ({ 'int_col' : tbl . other_int_col + 1 }) Increment int_col by 1 for all rows where int_col is 0: >>> tbl . update ({ 'int_col' : tbl . int_col + 1 }, where = tbl . int_col == 0 )","title":"InsertableTable"},{"location":"api/insertable-table/#insertabletable","text":"Import conventions: import pixeltable as pxt Instances of class InsertableTable are handles to Pixeltable tables. Use this handle to query and update the table and to add and drop columns. InsertableTable instances are created by calling pxt.create_table or pxt.get_table .","title":"InsertableTable"},{"location":"api/insertable-table/#overview","text":"Column Operations add_column Add a column to the table drop_column Remove a column from the table rename_column Rename a column Data Operations insert Insert rows into table update Upate rows in table delete Delete rows from table Versioning revert Revert the last change","title":"Overview"},{"location":"api/insertable-table/#pixeltable.InsertableTable","text":"A Table that allows inserting and deleting rows.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;InsertableTable"},{"location":"api/insertable-table/#pixeltable.InsertableTable.add_column","text":"add_column ( * , type : Optional [ ColumnType ] = None , stored : Optional [ bool ] = None , print_stats : bool = False , ** kwargs : Any ) -> UpdateStatus Adds a column to the table. Parameters: kwargs ( Any , default: {} ) \u2013 Exactly one keyword argument of the form column-name=type|value-expression . type ( Optional [ ColumnType ] , default: None ) \u2013 The type of the column. Only valid and required if value-expression is a Callable. stored ( Optional [ bool ] , default: None ) \u2013 Whether the column is materialized and stored or computed on demand. Only valid for image columns. print_stats ( bool , default: False ) \u2013 If True , print execution metrics. Returns: UpdateStatus \u2013 execution status Raises: Error \u2013 If the column name is invalid or already exists. Examples: Add an int column with None values: >>> tbl . add_column ( new_col = IntType ()) Alternatively, this can also be expressed as: >>> tbl [ 'new_col' ] = IntType () For a table with int column int_col , add a column that is the factorial of int_col . The names of the parameters of the Callable must correspond to existing column names (the column values are then passed as arguments to the Callable). In this case, the column type needs to be specified explicitly: >>> tbl . add_column ( factorial = lambda int_col : math . factorial ( int_col ), type = IntType ()) Alternatively, this can also be expressed as: >>> tbl [ 'factorial' ] = { 'value' : lambda int_col : math . factorial ( int_col ), 'type' : IntType ()} For a table with an image column frame , add an image column rotated that rotates the image by 90 degrees. In this case, the column type is inferred from the expression. Also, the column is not stored (by default, computed image columns are not stored but recomputed on demand): >>> tbl . add_column ( rotated = tbl . frame . rotate ( 90 )) Alternatively, this can also be expressed as: >>> tbl [ 'rotated' ] = tbl . frame . rotate ( 90 ) Do the same, but now the column is stored: >>> tbl . add_column ( rotated = tbl . frame . rotate ( 90 ), stored = True ) Alternatively, this can also be expressed as: >>> tbl [ 'rotated' ] = { 'value' : tbl . frame . rotate ( 90 ), 'stored' : True }","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;add_column"},{"location":"api/insertable-table/#pixeltable.InsertableTable.delete","text":"delete ( where : Optional [ 'pixeltable.exprs.Predicate' ] = None ) -> UpdateStatus Delete rows in this table. Parameters: where ( Optional ['pixeltable.exprs.Predicate'] , default: None ) \u2013 a Predicate to filter rows to delete. Examples: Delete all rows in a table: >>> tbl . delete () Delete all rows in a table where column a is greater than 5: >>> tbl . delete ( tbl . a > 5 )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;delete"},{"location":"api/insertable-table/#pixeltable.InsertableTable.drop_column","text":"drop_column ( name : str ) -> None Drop a column from the table. Parameters: name ( str ) \u2013 The name of the column to drop. Raises: Error \u2013 If the column does not exist or if it is referenced by a computed column. Examples: Drop column factorial : >>> tbl . drop_column ( 'factorial' )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;drop_column"},{"location":"api/insertable-table/#pixeltable.InsertableTable.insert","text":"insert ( * args , ** kwargs ) -> UpdateStatus Insert rows into table. To insert multiple rows at a time: insert(rows: List[Dict[str, Any]], print_stats: bool = False, fail_on_exception: bool = True) To insert just a single row, you can use the more convenient syntax: insert(print_stats: bool = False, fail_on_exception: bool = True, **kwargs: Any) Parameters: rows \u2013 (if inserting multiple rows) A list of rows to insert, each of which is a dictionary mapping column names to values. kwargs \u2013 (if inserting a single row) Keyword-argument pairs representing column names and values. print_stats \u2013 If True , print statistics about the cost of computed columns. fail_on_exception \u2013 Determines how exceptions in computed columns and invalid media files (e.g., corrupt images) are handled. If False , store error information (accessible as column properties 'errortype' and 'errormsg') for those cases, but continue inserting rows. If True , raise an exception that aborts the insert. Returns: UpdateStatus \u2013 execution status Raises: Error \u2013 if a row does not match the table schema or contains values for computed columns Examples: Insert two rows into a table with three int columns a , b , and c . Column c is nullable. >>> tbl . insert ([{ 'a' : 1 , 'b' : 1 , 'c' : 1 }, { 'a' : 2 , 'b' : 2 }]) Insert a single row into a table with three int columns a , b , and c . >>> tbl . insert ( a = 1 , b = 1 , c = 1 )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;insert"},{"location":"api/insertable-table/#pixeltable.InsertableTable.rename_column","text":"rename_column ( old_name : str , new_name : str ) -> None Rename a column. Parameters: old_name ( str ) \u2013 The current name of the column. new_name ( str ) \u2013 The new name of the column. Raises: Error \u2013 If the column does not exist or if the new name is invalid or already exists. Examples: Rename column factorial to fac : >>> tbl . rename_column ( 'factorial' , 'fac' )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;rename_column"},{"location":"api/insertable-table/#pixeltable.InsertableTable.revert","text":"revert () -> None Reverts the table to the previous version. .. warning:: This operation is irreversible.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;revert"},{"location":"api/insertable-table/#pixeltable.InsertableTable.update","text":"update ( value_spec : dict [ str , Any ], where : Optional [ \"pixeltable.exprs.Predicate\" ] = None , cascade : bool = True , ) -> UpdateStatus Update rows in this table. Parameters: value_spec ( dict [ str , Any ] ) \u2013 a dictionary mapping column names to literal values or Pixeltable expressions. where ( Optional ['pixeltable.exprs.Predicate'] , default: None ) \u2013 a Predicate to filter rows to update. cascade ( bool , default: True ) \u2013 if True, also update all computed columns that transitively depend on the updated columns. Examples: Set column int_col to 1 for all rows: >>> tbl . update ({ 'int_col' : 1 }) Set column int_col to 1 for all rows where int_col is 0: >>> tbl . update ({ 'int_col' : 1 }, where = tbl . int_col == 0 ) Set int_col to the value of other_int_col + 1: >>> tbl . update ({ 'int_col' : tbl . other_int_col + 1 }) Increment int_col by 1 for all rows where int_col is 0: >>> tbl . update ({ 'int_col' : tbl . int_col + 1 }, where = tbl . int_col == 0 )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;update"},{"location":"api/pixeltable/","text":"Pixeltable Import conventions: import pixeltable as pxt Insertable tables, views, and snapshots all have a tabular interface and are generically referred to as \"tables\" below. Overview Table Operations pxt.create_table Create a new (insertable) table pxt.create_view Create a new view pxt.drop_table Delete a table pxt.get_table Get a handle to a table pxt.list_tables List the tables in a directory Directory Operations pxt.create_dir Create a directory pxt.list_dirs List the directories in a directory pxt.rm_dir Remove a directory Misc pxt.configure_logging Configure logging pxt.init Initialize Pixeltable runtime now (if not already initialized) pxt.move Move a schema object to a new directory and/or rename a schema object pixeltable configure_logging configure_logging ( * , to_stdout : Optional [ bool ] = None , level : Optional [ int ] = None , add : Optional [ str ] = None , remove : Optional [ str ] = None ) -> None Configure logging. Parameters: to_stdout ( Optional [ bool ] , default: None ) \u2013 if True, also log to stdout level ( Optional [ int ] , default: None ) \u2013 default log level add ( Optional [ str ] , default: None ) \u2013 comma-separated list of 'module name:log level' pairs; ex.: add='video:10' remove ( Optional [ str ] , default: None ) \u2013 comma-separated list of module names create_dir create_dir ( path_str : str , ignore_errors : bool = False ) -> None Create a directory. Parameters: path_str ( str ) \u2013 Path to the directory. ignore_errors ( bool , default: False ) \u2013 if True, silently returns on error Raises: Error \u2013 If the path already exists or the parent is not a directory. Examples: >>> cl . create_dir ( 'my_dir' ) Create a subdirectory: >>> cl . create_dir ( 'my_dir.sub_dir' ) create_table create_table ( path_str : str , schema : dict [ str , Any ], * , primary_key : Optional [ Union [ str , list [ str ]]] = None , num_retained_versions : int = 10 , comment : str = \"\" ) -> InsertableTable Create a new InsertableTable . Parameters: path_str ( str ) \u2013 Path to the table. schema ( dict [ str , Any ] ) \u2013 dictionary mapping column names to column types, value expressions, or to column specifications. num_retained_versions ( int , default: 10 ) \u2013 Number of versions of the table to retain. Returns: InsertableTable \u2013 The newly created table. Raises: Error \u2013 if the path already exists or is invalid. Examples: Create a table with an int and a string column: >>> table = cl . create_table ( 'my_table' , schema = { 'col1' : IntType (), 'col2' : StringType ()}) create_view create_view ( path_str : str , base : Table , * , schema : Optional [ dict [ str , Any ]] = None , filter : Optional [ Predicate ] = None , is_snapshot : bool = False , iterator : Optional [ tuple [ type [ ComponentIterator ], dict [ str , Any ]]] = None , num_retained_versions : int = 10 , comment : str = \"\" , ignore_errors : bool = False ) -> View Create a new View . Parameters: path_str ( str ) \u2013 Path to the view. base ( Table ) \u2013 Table (ie, table or view or snapshot) to base the view on. schema ( Optional [ dict [ str , Any ]] , default: None ) \u2013 dictionary mapping column names to column types, value expressions, or to column specifications. filter ( Optional [ Predicate ] , default: None ) \u2013 Predicate to filter rows of the base table. is_snapshot ( bool , default: False ) \u2013 Whether the view is a snapshot. iterator_class \u2013 Class of the iterator to use for the view. iterator_args \u2013 Arguments to pass to the iterator class. num_retained_versions ( int , default: 10 ) \u2013 Number of versions of the view to retain. ignore_errors ( bool , default: False ) \u2013 if True, fail silently if the path already exists or is invalid. Returns: View \u2013 The newly created view. Raises: Error \u2013 if the path already exists or is invalid. Examples: Create a view with an additional int and a string column and a filter: >>> view = cl . create_view ( 'my_view', base, schema={'col3': IntType(), 'col4': StringType()}, filter=base.col1 > 10) Create a table snapshot: >>> snapshot_view = cl . create_view ( 'my_snapshot_view' , base , is_snapshot = True ) Create an immutable view with additional computed columns and a filter: >>> snapshot_view = cl . create_view ( 'my_snapshot', base, schema={'col3': base.col2 + 1}, filter=base.col1 > 10, is_snapshot=True) drop_table drop_table ( path : str , force : bool = False , ignore_errors : bool = False ) -> None Drop a table. Parameters: path ( str ) \u2013 Path to the table. force ( bool , default: False ) \u2013 Whether to drop the table even if it has unsaved changes. ignore_errors ( bool , default: False ) \u2013 Whether to ignore errors if the table does not exist. Raises: Error \u2013 If the path does not exist or does not designate a table and ignore_errors is False. Examples: >>> cl . drop_table ( 'my_table' ) get_table get_table ( path : str ) -> Table Get a handle to a table (including views and snapshots). Parameters: path ( str ) \u2013 Path to the table. Returns: Table \u2013 A InsertableTable or View object. Raises: Error \u2013 If the path does not exist or does not designate a table. Examples: Get handle for a table in the top-level directory: >>> table = cl . get_table ( 'my_table' ) For a table in a subdirectory: >>> table = cl . get_table ( 'subdir.my_table' ) For a snapshot in the top-level directory: >>> table = cl . get_table ( 'my_snapshot' ) init init () -> None Initializes the Pixeltable environment. list_tables list_tables ( dir_path : str = '' , recursive : bool = True ) -> list [ str ] List the tables in a directory. Parameters: dir_path ( str , default: '' ) \u2013 Path to the directory. Defaults to the root directory. recursive ( bool , default: True ) \u2013 Whether to list tables in subdirectories as well. Returns: list [ str ] \u2013 A list of table paths. Raises: Error \u2013 If the path does not exist or does not designate a directory. Examples: List tables in top-level directory: >>> cl . list_tables () ['my_table', ...] List tables in 'dir1': >>> cl . list_tables ( 'dir1' ) [...] list_dirs list_dirs ( path_str : str = '' , recursive : bool = True ) -> list [ str ] List the directories in a directory. Parameters: path_str ( str , default: '' ) \u2013 Path to the directory. recursive ( bool , default: True ) \u2013 Whether to list subdirectories recursively. Returns: list [ str ] \u2013 List of directory paths. Raises: Error \u2013 If the path does not exist or does not designate a directory. Examples: >>> cl . list_dirs ( 'my_dir' , recursive = True ) ['my_dir', 'my_dir.sub_dir1'] move move ( path : str , new_path : str ) -> None Move a schema object to a new directory and/or rename a schema object. Parameters: path ( str ) \u2013 absolute path to the existing schema object. new_path ( str ) \u2013 absolute new path for the schema object. Raises: Error \u2013 If path does not exist or new_path already exists. Examples: Move a table to a different directory: >>>> cl.move('dir1.my_table', 'dir2.my_table') Rename a table: >>>> cl.move('dir1.my_table', 'dir1.new_name') rm_dir rm_dir ( path_str : str ) -> None Remove a directory. Parameters: path_str ( str ) \u2013 Path to the directory. Raises: Error \u2013 If the path does not exist or does not designate a directory or if the directory is not empty. Examples: >>> cl . rm_dir ( 'my_dir' ) Remove a subdirectory: >>> cl . rm_dir ( 'my_dir.sub_dir' )","title":"Pixeltable"},{"location":"api/pixeltable/#pixeltable_1","text":"Import conventions: import pixeltable as pxt Insertable tables, views, and snapshots all have a tabular interface and are generically referred to as \"tables\" below.","title":"Pixeltable"},{"location":"api/pixeltable/#overview","text":"Table Operations pxt.create_table Create a new (insertable) table pxt.create_view Create a new view pxt.drop_table Delete a table pxt.get_table Get a handle to a table pxt.list_tables List the tables in a directory Directory Operations pxt.create_dir Create a directory pxt.list_dirs List the directories in a directory pxt.rm_dir Remove a directory Misc pxt.configure_logging Configure logging pxt.init Initialize Pixeltable runtime now (if not already initialized) pxt.move Move a schema object to a new directory and/or rename a schema object","title":"Overview"},{"location":"api/pixeltable/#pixeltable","text":"","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-module\"></code>&nbsp;pixeltable"},{"location":"api/pixeltable/#pixeltable.configure_logging","text":"configure_logging ( * , to_stdout : Optional [ bool ] = None , level : Optional [ int ] = None , add : Optional [ str ] = None , remove : Optional [ str ] = None ) -> None Configure logging. Parameters: to_stdout ( Optional [ bool ] , default: None ) \u2013 if True, also log to stdout level ( Optional [ int ] , default: None ) \u2013 default log level add ( Optional [ str ] , default: None ) \u2013 comma-separated list of 'module name:log level' pairs; ex.: add='video:10' remove ( Optional [ str ] , default: None ) \u2013 comma-separated list of module names","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-function\"></code>&nbsp;configure_logging"},{"location":"api/pixeltable/#pixeltable.create_dir","text":"create_dir ( path_str : str , ignore_errors : bool = False ) -> None Create a directory. Parameters: path_str ( str ) \u2013 Path to the directory. ignore_errors ( bool , default: False ) \u2013 if True, silently returns on error Raises: Error \u2013 If the path already exists or the parent is not a directory. Examples: >>> cl . create_dir ( 'my_dir' ) Create a subdirectory: >>> cl . create_dir ( 'my_dir.sub_dir' )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-function\"></code>&nbsp;create_dir"},{"location":"api/pixeltable/#pixeltable.create_table","text":"create_table ( path_str : str , schema : dict [ str , Any ], * , primary_key : Optional [ Union [ str , list [ str ]]] = None , num_retained_versions : int = 10 , comment : str = \"\" ) -> InsertableTable Create a new InsertableTable . Parameters: path_str ( str ) \u2013 Path to the table. schema ( dict [ str , Any ] ) \u2013 dictionary mapping column names to column types, value expressions, or to column specifications. num_retained_versions ( int , default: 10 ) \u2013 Number of versions of the table to retain. Returns: InsertableTable \u2013 The newly created table. Raises: Error \u2013 if the path already exists or is invalid. Examples: Create a table with an int and a string column: >>> table = cl . create_table ( 'my_table' , schema = { 'col1' : IntType (), 'col2' : StringType ()})","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-function\"></code>&nbsp;create_table"},{"location":"api/pixeltable/#pixeltable.create_view","text":"create_view ( path_str : str , base : Table , * , schema : Optional [ dict [ str , Any ]] = None , filter : Optional [ Predicate ] = None , is_snapshot : bool = False , iterator : Optional [ tuple [ type [ ComponentIterator ], dict [ str , Any ]]] = None , num_retained_versions : int = 10 , comment : str = \"\" , ignore_errors : bool = False ) -> View Create a new View . Parameters: path_str ( str ) \u2013 Path to the view. base ( Table ) \u2013 Table (ie, table or view or snapshot) to base the view on. schema ( Optional [ dict [ str , Any ]] , default: None ) \u2013 dictionary mapping column names to column types, value expressions, or to column specifications. filter ( Optional [ Predicate ] , default: None ) \u2013 Predicate to filter rows of the base table. is_snapshot ( bool , default: False ) \u2013 Whether the view is a snapshot. iterator_class \u2013 Class of the iterator to use for the view. iterator_args \u2013 Arguments to pass to the iterator class. num_retained_versions ( int , default: 10 ) \u2013 Number of versions of the view to retain. ignore_errors ( bool , default: False ) \u2013 if True, fail silently if the path already exists or is invalid. Returns: View \u2013 The newly created view. Raises: Error \u2013 if the path already exists or is invalid. Examples: Create a view with an additional int and a string column and a filter: >>> view = cl . create_view ( 'my_view', base, schema={'col3': IntType(), 'col4': StringType()}, filter=base.col1 > 10) Create a table snapshot: >>> snapshot_view = cl . create_view ( 'my_snapshot_view' , base , is_snapshot = True ) Create an immutable view with additional computed columns and a filter: >>> snapshot_view = cl . create_view ( 'my_snapshot', base, schema={'col3': base.col2 + 1}, filter=base.col1 > 10, is_snapshot=True)","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-function\"></code>&nbsp;create_view"},{"location":"api/pixeltable/#pixeltable.drop_table","text":"drop_table ( path : str , force : bool = False , ignore_errors : bool = False ) -> None Drop a table. Parameters: path ( str ) \u2013 Path to the table. force ( bool , default: False ) \u2013 Whether to drop the table even if it has unsaved changes. ignore_errors ( bool , default: False ) \u2013 Whether to ignore errors if the table does not exist. Raises: Error \u2013 If the path does not exist or does not designate a table and ignore_errors is False. Examples: >>> cl . drop_table ( 'my_table' )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-function\"></code>&nbsp;drop_table"},{"location":"api/pixeltable/#pixeltable.get_table","text":"get_table ( path : str ) -> Table Get a handle to a table (including views and snapshots). Parameters: path ( str ) \u2013 Path to the table. Returns: Table \u2013 A InsertableTable or View object. Raises: Error \u2013 If the path does not exist or does not designate a table. Examples: Get handle for a table in the top-level directory: >>> table = cl . get_table ( 'my_table' ) For a table in a subdirectory: >>> table = cl . get_table ( 'subdir.my_table' ) For a snapshot in the top-level directory: >>> table = cl . get_table ( 'my_snapshot' )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-function\"></code>&nbsp;get_table"},{"location":"api/pixeltable/#pixeltable.init","text":"init () -> None Initializes the Pixeltable environment.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-function\"></code>&nbsp;init"},{"location":"api/pixeltable/#pixeltable.list_tables","text":"list_tables ( dir_path : str = '' , recursive : bool = True ) -> list [ str ] List the tables in a directory. Parameters: dir_path ( str , default: '' ) \u2013 Path to the directory. Defaults to the root directory. recursive ( bool , default: True ) \u2013 Whether to list tables in subdirectories as well. Returns: list [ str ] \u2013 A list of table paths. Raises: Error \u2013 If the path does not exist or does not designate a directory. Examples: List tables in top-level directory: >>> cl . list_tables () ['my_table', ...] List tables in 'dir1': >>> cl . list_tables ( 'dir1' ) [...]","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-function\"></code>&nbsp;list_tables"},{"location":"api/pixeltable/#pixeltable.list_dirs","text":"list_dirs ( path_str : str = '' , recursive : bool = True ) -> list [ str ] List the directories in a directory. Parameters: path_str ( str , default: '' ) \u2013 Path to the directory. recursive ( bool , default: True ) \u2013 Whether to list subdirectories recursively. Returns: list [ str ] \u2013 List of directory paths. Raises: Error \u2013 If the path does not exist or does not designate a directory. Examples: >>> cl . list_dirs ( 'my_dir' , recursive = True ) ['my_dir', 'my_dir.sub_dir1']","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-function\"></code>&nbsp;list_dirs"},{"location":"api/pixeltable/#pixeltable.move","text":"move ( path : str , new_path : str ) -> None Move a schema object to a new directory and/or rename a schema object. Parameters: path ( str ) \u2013 absolute path to the existing schema object. new_path ( str ) \u2013 absolute new path for the schema object. Raises: Error \u2013 If path does not exist or new_path already exists. Examples: Move a table to a different directory: >>>> cl.move('dir1.my_table', 'dir2.my_table') Rename a table: >>>> cl.move('dir1.my_table', 'dir1.new_name')","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-function\"></code>&nbsp;move"},{"location":"api/pixeltable/#pixeltable.rm_dir","text":"rm_dir ( path_str : str ) -> None Remove a directory. Parameters: path_str ( str ) \u2013 Path to the directory. Raises: Error \u2013 If the path does not exist or does not designate a directory or if the directory is not empty. Examples: >>> cl . rm_dir ( 'my_dir' ) Remove a subdirectory: >>> cl . rm_dir ( 'my_dir.sub_dir' )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-function\"></code>&nbsp;rm_dir"},{"location":"api/table/","text":"Table The Table base class provides convenience functions for querying tables and views without having to construct DataFrame instances explicitly. pixeltable.Table Base class for all tabular SchemaObjects. __getattr__ __getattr__ ( col_name : str ) -> 'pixeltable.exprs.ColumnRef' Return a ColumnRef for the given column name. __getitem__ __getitem__ ( index : object , ) -> Union [ \"pixeltable.exprs.ColumnRef\" , \"pixeltable.dataframe.DataFrame\" ] Return a ColumnRef for the given column name, or a DataFrame for the given slice. collect collect () -> 'pixeltable.dataframe.DataFrameResultSet' Return rows from this table. count count () -> int Return the number of rows in this table. describe describe () -> None df df () -> 'pixeltable.dataframe.DataFrame' Return a DataFrame for this table. head head ( * args , ** kwargs ) -> 'pixeltable.dataframe.DataFrameResultSet' Return the first n rows inserted into this table. select select ( * items : Any , ** named_items : Any ) -> 'pixeltable.dataframe.DataFrame' Return a DataFrame for this table. show show ( * args , ** kwargs ) -> 'pixeltable.dataframe.DataFrameResultSet' Return rows from this table. where where ( pred : 'exprs.Predicate' ) -> 'pixeltable.dataframe.DataFrame' Return a DataFrame for this table. tail tail ( * args , ** kwargs ) -> 'pixeltable.dataframe.DataFrameResultSet' Return the last n rows inserted into this table.","title":"Table"},{"location":"api/table/#table","text":"The Table base class provides convenience functions for querying tables and views without having to construct DataFrame instances explicitly.","title":"Table"},{"location":"api/table/#pixeltable.Table","text":"Base class for all tabular SchemaObjects.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;Table"},{"location":"api/table/#pixeltable.Table.__getattr__","text":"__getattr__ ( col_name : str ) -> 'pixeltable.exprs.ColumnRef' Return a ColumnRef for the given column name.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__getattr__"},{"location":"api/table/#pixeltable.Table.__getitem__","text":"__getitem__ ( index : object , ) -> Union [ \"pixeltable.exprs.ColumnRef\" , \"pixeltable.dataframe.DataFrame\" ] Return a ColumnRef for the given column name, or a DataFrame for the given slice.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;__getitem__"},{"location":"api/table/#pixeltable.Table.collect","text":"collect () -> 'pixeltable.dataframe.DataFrameResultSet' Return rows from this table.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;collect"},{"location":"api/table/#pixeltable.Table.count","text":"count () -> int Return the number of rows in this table.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;count"},{"location":"api/table/#pixeltable.Table.describe","text":"describe () -> None","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;describe"},{"location":"api/table/#pixeltable.Table.df","text":"df () -> 'pixeltable.dataframe.DataFrame' Return a DataFrame for this table.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;df"},{"location":"api/table/#pixeltable.Table.head","text":"head ( * args , ** kwargs ) -> 'pixeltable.dataframe.DataFrameResultSet' Return the first n rows inserted into this table.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;head"},{"location":"api/table/#pixeltable.Table.select","text":"select ( * items : Any , ** named_items : Any ) -> 'pixeltable.dataframe.DataFrame' Return a DataFrame for this table.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;select"},{"location":"api/table/#pixeltable.Table.show","text":"show ( * args , ** kwargs ) -> 'pixeltable.dataframe.DataFrameResultSet' Return rows from this table.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;show"},{"location":"api/table/#pixeltable.Table.where","text":"where ( pred : 'exprs.Predicate' ) -> 'pixeltable.dataframe.DataFrame' Return a DataFrame for this table.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;where"},{"location":"api/table/#pixeltable.Table.tail","text":"tail ( * args , ** kwargs ) -> 'pixeltable.dataframe.DataFrameResultSet' Return the last n rows inserted into this table.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;tail"},{"location":"api/view/","text":"View Import conventions: import pixeltable as pxt Instances of class View are handles to Pixeltable views and snapshots (the latter require is_snapshot=True when creating the view). Use this handle to query and update the view and to add and drop columns. View instances are created by calling pxt.create_view or pxt.get_table . Overview Column Operations add_column Adds a column to the view drop_column Removes a column from the view rename_column Renames a column Data Operations update Update rows in the view Versioning revert Revert the last change to the view pixeltable.View A Table that presents a virtual view of another table (or view). A view is typically backed by a store table, which records the view's columns and is joined back to the bases at query execution time. The exception is a snapshot view without a predicate and without additional columns: in that case, the view is simply a reference to a specific set of base versions. add_column add_column ( * , type : Optional [ ColumnType ] = None , stored : Optional [ bool ] = None , print_stats : bool = False , ** kwargs : Any ) -> UpdateStatus Adds a column to the table. Parameters: kwargs ( Any , default: {} ) \u2013 Exactly one keyword argument of the form column-name=type|value-expression . type ( Optional [ ColumnType ] , default: None ) \u2013 The type of the column. Only valid and required if value-expression is a Callable. stored ( Optional [ bool ] , default: None ) \u2013 Whether the column is materialized and stored or computed on demand. Only valid for image columns. print_stats ( bool , default: False ) \u2013 If True , print execution metrics. Returns: UpdateStatus \u2013 execution status Raises: Error \u2013 If the column name is invalid or already exists. Examples: Add an int column with None values: >>> tbl . add_column ( new_col = IntType ()) Alternatively, this can also be expressed as: >>> tbl [ 'new_col' ] = IntType () For a table with int column int_col , add a column that is the factorial of int_col . The names of the parameters of the Callable must correspond to existing column names (the column values are then passed as arguments to the Callable). In this case, the column type needs to be specified explicitly: >>> tbl . add_column ( factorial = lambda int_col : math . factorial ( int_col ), type = IntType ()) Alternatively, this can also be expressed as: >>> tbl [ 'factorial' ] = { 'value' : lambda int_col : math . factorial ( int_col ), 'type' : IntType ()} For a table with an image column frame , add an image column rotated that rotates the image by 90 degrees. In this case, the column type is inferred from the expression. Also, the column is not stored (by default, computed image columns are not stored but recomputed on demand): >>> tbl . add_column ( rotated = tbl . frame . rotate ( 90 )) Alternatively, this can also be expressed as: >>> tbl [ 'rotated' ] = tbl . frame . rotate ( 90 ) Do the same, but now the column is stored: >>> tbl . add_column ( rotated = tbl . frame . rotate ( 90 ), stored = True ) Alternatively, this can also be expressed as: >>> tbl [ 'rotated' ] = { 'value' : tbl . frame . rotate ( 90 ), 'stored' : True } drop_column drop_column ( name : str ) -> None Drop a column from the table. Parameters: name ( str ) \u2013 The name of the column to drop. Raises: Error \u2013 If the column does not exist or if it is referenced by a computed column. Examples: Drop column factorial : >>> tbl . drop_column ( 'factorial' ) rename_column rename_column ( old_name : str , new_name : str ) -> None Rename a column. Parameters: old_name ( str ) \u2013 The current name of the column. new_name ( str ) \u2013 The new name of the column. Raises: Error \u2013 If the column does not exist or if the new name is invalid or already exists. Examples: Rename column factorial to fac : >>> tbl . rename_column ( 'factorial' , 'fac' ) revert revert () -> None Reverts the table to the previous version. .. warning:: This operation is irreversible. update update ( value_spec : dict [ str , Any ], where : Optional [ \"pixeltable.exprs.Predicate\" ] = None , cascade : bool = True , ) -> UpdateStatus Update rows in this table. Parameters: value_spec ( dict [ str , Any ] ) \u2013 a dictionary mapping column names to literal values or Pixeltable expressions. where ( Optional ['pixeltable.exprs.Predicate'] , default: None ) \u2013 a Predicate to filter rows to update. cascade ( bool , default: True ) \u2013 if True, also update all computed columns that transitively depend on the updated columns. Examples: Set column int_col to 1 for all rows: >>> tbl . update ({ 'int_col' : 1 }) Set column int_col to 1 for all rows where int_col is 0: >>> tbl . update ({ 'int_col' : 1 }, where = tbl . int_col == 0 ) Set int_col to the value of other_int_col + 1: >>> tbl . update ({ 'int_col' : tbl . other_int_col + 1 }) Increment int_col by 1 for all rows where int_col is 0: >>> tbl . update ({ 'int_col' : tbl . int_col + 1 }, where = tbl . int_col == 0 )","title":"View"},{"location":"api/view/#view","text":"Import conventions: import pixeltable as pxt Instances of class View are handles to Pixeltable views and snapshots (the latter require is_snapshot=True when creating the view). Use this handle to query and update the view and to add and drop columns. View instances are created by calling pxt.create_view or pxt.get_table .","title":"View"},{"location":"api/view/#overview","text":"Column Operations add_column Adds a column to the view drop_column Removes a column from the view rename_column Renames a column Data Operations update Update rows in the view Versioning revert Revert the last change to the view","title":"Overview"},{"location":"api/view/#pixeltable.View","text":"A Table that presents a virtual view of another table (or view). A view is typically backed by a store table, which records the view's columns and is joined back to the bases at query execution time. The exception is a snapshot view without a predicate and without additional columns: in that case, the view is simply a reference to a specific set of base versions.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-class\"></code>&nbsp;View"},{"location":"api/view/#pixeltable.View.add_column","text":"add_column ( * , type : Optional [ ColumnType ] = None , stored : Optional [ bool ] = None , print_stats : bool = False , ** kwargs : Any ) -> UpdateStatus Adds a column to the table. Parameters: kwargs ( Any , default: {} ) \u2013 Exactly one keyword argument of the form column-name=type|value-expression . type ( Optional [ ColumnType ] , default: None ) \u2013 The type of the column. Only valid and required if value-expression is a Callable. stored ( Optional [ bool ] , default: None ) \u2013 Whether the column is materialized and stored or computed on demand. Only valid for image columns. print_stats ( bool , default: False ) \u2013 If True , print execution metrics. Returns: UpdateStatus \u2013 execution status Raises: Error \u2013 If the column name is invalid or already exists. Examples: Add an int column with None values: >>> tbl . add_column ( new_col = IntType ()) Alternatively, this can also be expressed as: >>> tbl [ 'new_col' ] = IntType () For a table with int column int_col , add a column that is the factorial of int_col . The names of the parameters of the Callable must correspond to existing column names (the column values are then passed as arguments to the Callable). In this case, the column type needs to be specified explicitly: >>> tbl . add_column ( factorial = lambda int_col : math . factorial ( int_col ), type = IntType ()) Alternatively, this can also be expressed as: >>> tbl [ 'factorial' ] = { 'value' : lambda int_col : math . factorial ( int_col ), 'type' : IntType ()} For a table with an image column frame , add an image column rotated that rotates the image by 90 degrees. In this case, the column type is inferred from the expression. Also, the column is not stored (by default, computed image columns are not stored but recomputed on demand): >>> tbl . add_column ( rotated = tbl . frame . rotate ( 90 )) Alternatively, this can also be expressed as: >>> tbl [ 'rotated' ] = tbl . frame . rotate ( 90 ) Do the same, but now the column is stored: >>> tbl . add_column ( rotated = tbl . frame . rotate ( 90 ), stored = True ) Alternatively, this can also be expressed as: >>> tbl [ 'rotated' ] = { 'value' : tbl . frame . rotate ( 90 ), 'stored' : True }","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;add_column"},{"location":"api/view/#pixeltable.View.drop_column","text":"drop_column ( name : str ) -> None Drop a column from the table. Parameters: name ( str ) \u2013 The name of the column to drop. Raises: Error \u2013 If the column does not exist or if it is referenced by a computed column. Examples: Drop column factorial : >>> tbl . drop_column ( 'factorial' )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;drop_column"},{"location":"api/view/#pixeltable.View.rename_column","text":"rename_column ( old_name : str , new_name : str ) -> None Rename a column. Parameters: old_name ( str ) \u2013 The current name of the column. new_name ( str ) \u2013 The new name of the column. Raises: Error \u2013 If the column does not exist or if the new name is invalid or already exists. Examples: Rename column factorial to fac : >>> tbl . rename_column ( 'factorial' , 'fac' )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;rename_column"},{"location":"api/view/#pixeltable.View.revert","text":"revert () -> None Reverts the table to the previous version. .. warning:: This operation is irreversible.","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;revert"},{"location":"api/view/#pixeltable.View.update","text":"update ( value_spec : dict [ str , Any ], where : Optional [ \"pixeltable.exprs.Predicate\" ] = None , cascade : bool = True , ) -> UpdateStatus Update rows in this table. Parameters: value_spec ( dict [ str , Any ] ) \u2013 a dictionary mapping column names to literal values or Pixeltable expressions. where ( Optional ['pixeltable.exprs.Predicate'] , default: None ) \u2013 a Predicate to filter rows to update. cascade ( bool , default: True ) \u2013 if True, also update all computed columns that transitively depend on the updated columns. Examples: Set column int_col to 1 for all rows: >>> tbl . update ({ 'int_col' : 1 }) Set column int_col to 1 for all rows where int_col is 0: >>> tbl . update ({ 'int_col' : 1 }, where = tbl . int_col == 0 ) Set int_col to the value of other_int_col + 1: >>> tbl . update ({ 'int_col' : tbl . other_int_col + 1 }) Increment int_col by 1 for all rows where int_col is 0: >>> tbl . update ({ 'int_col' : tbl . int_col + 1 }, where = tbl . int_col == 0 )","title":"<code class=\"doc-symbol doc-symbol-toc doc-symbol-method\"></code>&nbsp;update"}]}